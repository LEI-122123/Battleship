


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > Ship</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">iscteiul.ista.battleship</a>
</div>

<h1>Coverage Summary for Class: Ship (iscteiul.ista.battleship)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Ship</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (51/51)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (64/64)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * **Classe Abstrata Base para todos os Navios (Ship) no jogo Batalha Naval.**
&nbsp; * Fornece a implementação comum para a maioria dos métodos definidos em {@code IShip},
&nbsp; * incluindo a gestão das posições, orientação, verificação de limites e colisões,
&nbsp; * e o estado de flutuação.
&nbsp; *
&nbsp; * @author [Seu Nome/Nome da Equipe, se aplicável]
&nbsp; * @version 1.0
&nbsp; */
&nbsp;package iscteiul.ista.battleship;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;
<b class="fc">&nbsp;public abstract class Ship implements IShip {</b>
&nbsp;
&nbsp;    /** Constante para a categoria Galeão. */
&nbsp;    private static final String GALEAO = &quot;galeao&quot;;
&nbsp;    /** Constante para a categoria Fragata. */
&nbsp;    private static final String FRAGATA = &quot;fragata&quot;;
&nbsp;    /** Constante para a categoria Nau (Carrack). */
&nbsp;    private static final String NAU = &quot;nau&quot;;
&nbsp;    /** Constante para a categoria Caravela. */
&nbsp;    private static final String CARAVELA = &quot;caravela&quot;;
&nbsp;    /** Constante para a categoria Barca. */
&nbsp;    private static final String BARCA = &quot;barca&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * **Método estático para construir uma instância específica de Navio (Ship) com base na categoria.**
&nbsp;     * Funciona como um *factory method* simples.
&nbsp;     *
&nbsp;     * @param shipKind A categoria/tipo do navio a ser construído (ex: &quot;caravela&quot;, &quot;fragata&quot;).
&nbsp;     * @param bearing A orientação ({@code Compass}) do novo navio.
&nbsp;     * @param pos O ponto inicial ({@code Position}) para posicionar o navio.
&nbsp;     * @return Uma instância do tipo de navio correspondente, ou {@code null} se a categoria for desconhecida.
&nbsp;     */
&nbsp;    static Ship buildShip(String shipKind, Compass bearing, Position pos) {
&nbsp;        Ship s;
<b class="fc">&nbsp;        switch (shipKind) {</b>
&nbsp;            case BARCA:
<b class="fc">&nbsp;                s = new Barge(bearing, pos);</b>
&nbsp;                break;
&nbsp;            case CARAVELA:
<b class="fc">&nbsp;                s = new Caravel(bearing, pos);</b>
&nbsp;                break;
&nbsp;            case NAU:
<b class="fc">&nbsp;                s = new Carrack(bearing, pos);</b>
&nbsp;                break;
&nbsp;            case FRAGATA:
<b class="fc">&nbsp;                s = new Frigate(bearing, pos);</b>
&nbsp;                break;
&nbsp;            case GALEAO:
<b class="fc">&nbsp;                s = new Galleon(bearing, pos);</b>
&nbsp;                break;
&nbsp;            default:
<b class="fc">&nbsp;                s = null;</b>
&nbsp;        }
<b class="fc">&nbsp;        return s;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /** A categoria (nome) do navio (ex: &quot;Nau&quot;). */
&nbsp;    private String category;
&nbsp;    /** A orientação (Norte, Sul, Este, Oeste) do navio. */
&nbsp;    private Compass bearing;
&nbsp;    /** A posição de referência (superior esquerda) do navio. */
&nbsp;    private IPosition pos;
&nbsp;    /** A lista das posições (células) que este navio ocupa no tabuleiro. */
&nbsp;    protected List&lt;IPosition&gt; positions;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * **Construtor da classe base Ship.**
&nbsp;     * Inicializa os atributos fundamentais do navio. As subclasses são responsáveis
&nbsp;     * por preencher a lista {@code positions} de acordo com o seu formato e tamanho.
&nbsp;     *
&nbsp;     * @param category A categoria/nome do navio.
&nbsp;     * @param bearing A orientação ({@code Compass}) do navio.
&nbsp;     * @param pos A posição de referência ({@code IPosition}) do navio.
&nbsp;     */
<b class="fc">&nbsp;    public Ship(String category, Compass bearing, IPosition pos) {</b>
<b class="fc">&nbsp;        assert bearing != null;</b>
<b class="fc">&nbsp;        assert pos != null;</b>
&nbsp;
<b class="fc">&nbsp;        this.category = category;</b>
<b class="fc">&nbsp;        this.bearing = bearing;</b>
<b class="fc">&nbsp;        this.pos = pos;</b>
<b class="fc">&nbsp;        positions = new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém a categoria (nome/tipo) deste navio.**
&nbsp;     *
&nbsp;     * @return A categoria do navio.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String getCategory() {
<b class="fc">&nbsp;        return category;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém a lista de todas as posições (células) que este navio ocupa no tabuleiro.**
&nbsp;     *
&nbsp;     * @return A lista ({@code List&lt;IPosition&gt;}) das posições ocupadas.
&nbsp;     */
&nbsp;    public List&lt;IPosition&gt; getPositions() {
<b class="fc">&nbsp;        return positions;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém a posição inicial ou de referência (canto superior/esquerdo) do navio.**
&nbsp;     *
&nbsp;     * @return A posição de referência ({@code IPosition}).
&nbsp;     */
&nbsp;    @Override
&nbsp;    public IPosition getPosition() {
<b class="fc">&nbsp;        return pos;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém a orientação (bearing) deste navio.**
&nbsp;     *
&nbsp;     * @return A orientação ({@code Compass}) do navio.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public Compass getBearing() {
<b class="fc">&nbsp;        return bearing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Verifica se o navio ainda está a flutuar (ainda não foi afundado).**
&nbsp;     *
&nbsp;     * @return {@code true} se pelo menos uma posição do navio não foi atingida; {@code false} caso contrário (afundado).
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean stillFloating() {
<b class="fc">&nbsp;        for (int i = 0; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (!getPositions().get(i).isHit())</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém o índice da linha mais alta (Top) ocupada pelo navio.**
&nbsp;     *
&nbsp;     * @return O valor inteiro da linha mais alta.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getTopMostPos() {
<b class="fc">&nbsp;        int top = getPositions().get(0).getRow();</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).getRow() &lt; top)</b>
<b class="fc">&nbsp;                top = getPositions().get(i).getRow();</b>
<b class="fc">&nbsp;        return top;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém o índice da linha mais baixa (Bottom) ocupada pelo navio.**
&nbsp;     *
&nbsp;     * @return O valor inteiro da linha mais baixa.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getBottomMostPos() {
<b class="fc">&nbsp;        int bottom = getPositions().get(0).getRow();</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).getRow() &gt; bottom)</b>
<b class="fc">&nbsp;                bottom = getPositions().get(i).getRow();</b>
<b class="fc">&nbsp;        return bottom;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém o índice da coluna mais à esquerda (Left) ocupada pelo navio.**
&nbsp;     *
&nbsp;     * @return O valor inteiro da coluna mais à esquerda.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getLeftMostPos() {
<b class="fc">&nbsp;        int left = getPositions().get(0).getColumn();</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).getColumn() &lt; left)</b>
<b class="fc">&nbsp;                left = getPositions().get(i).getColumn();</b>
<b class="fc">&nbsp;        return left;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Obtém o índice da coluna mais à direita (Right) ocupada pelo navio.**
&nbsp;     *
&nbsp;     * @return O valor inteiro da coluna mais à direita.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public int getRightMostPos() {
<b class="fc">&nbsp;        int right = getPositions().get(0).getColumn();</b>
<b class="fc">&nbsp;        for (int i = 1; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).getColumn() &gt; right)</b>
<b class="fc">&nbsp;                right = getPositions().get(i).getColumn();</b>
<b class="fc">&nbsp;        return right;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Verifica se o navio ocupa uma determinada posição.**
&nbsp;     *
&nbsp;     * @param pos A posição ({@code IPosition}) a ser verificada.
&nbsp;     * @return {@code true} se o navio ocupar essa posição; {@code false} caso contrário.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean occupies(IPosition pos) {
<b class="fc">&nbsp;        assert pos != null;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).equals(pos))</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Verifica se este navio está demasiado perto de outro navio.**
&nbsp;     * Percorre todas as posições do outro navio e verifica se alguma é adjacente a qualquer posição deste navio.
&nbsp;     *
&nbsp;     * @param other O outro navio ({@code IShip}) para comparação.
&nbsp;     * @return {@code true} se houver adjacência entre qualquer posição dos dois navios; {@code false} caso contrário.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean tooCloseTo(IShip other) {
<b class="fc">&nbsp;        assert other != null;</b>
&nbsp;
<b class="fc">&nbsp;        Iterator&lt;IPosition&gt; otherPos = other.getPositions().iterator();</b>
<b class="fc">&nbsp;        while (otherPos.hasNext())</b>
<b class="fc">&nbsp;            if (tooCloseTo(otherPos.next()))</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * **Verifica se o navio está demasiado perto de uma posição específica.**
&nbsp;     * Um navio está &quot;too close&quot; se qualquer uma das suas posições for adjacente (vizinha, incluindo diagonal)
&nbsp;     * à posição fornecida.
&nbsp;     *
&nbsp;     * @param pos A posição ({@code IPosition}) a ser verificada.
&nbsp;     * @return {@code true} se o navio estiver demasiado próximo da posição; {@code false} caso contrário.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public boolean tooCloseTo(IPosition pos) {
<b class="fc">&nbsp;        for (int i = 0; i &lt; this.getSize(); i++)</b>
<b class="fc">&nbsp;            if (getPositions().get(i).isAdjacentTo(pos))</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * **Marca uma posição específica do navio como atingida (shot).**
&nbsp;     * Percorre as posições e, se encontrar a correspondência, marca-a como atingida.
&nbsp;     *
&nbsp;     * @param pos A posição ({@code IPosition}) onde o tiro acertou.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public void shoot(IPosition pos) {
<b class="fc">&nbsp;        assert pos != null;</b>
&nbsp;
<b class="fc">&nbsp;        for (IPosition position : getPositions()) {</b>
<b class="fc">&nbsp;            if (position.equals(pos))</b>
<b class="fc">&nbsp;                position.shoot();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * **Fornece uma representação em String deste navio.**
&nbsp;     * O formato inclui a categoria, orientação e posição de referência.
&nbsp;     *
&nbsp;     * @return Uma string formatada com os atributos do navio.
&nbsp;     */
&nbsp;    @Override
&nbsp;    public String toString() {
<b class="fc">&nbsp;        return &quot;[&quot; + category + &quot; &quot; + bearing + &quot; &quot; + pos + &quot;]&quot;;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-11-11 11:34</div>
</div>
</body>
</html>
